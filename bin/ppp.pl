# Copyright (c) 2016 Thomas C. Jones 
# Copyright (c) 2007 Echelon Corporation
#
# Description:
#   Yet Another Perl PreProcessor - Perl-based Metaprogramming Language
#   This one is a stand-alone Perl script (not packages to install)
#   Syntax is very simple:
#
#       ! {any Perl}
#        {any nonPerl w/ interpolable Perl variables}
#
#   Of course, nothing is that simple.  Since many languages use many of 
#   the same special characters as Perl it is necessary to escape the 
#   Perl special charaters when embedding them in the target lines.
#   In particular: {}[]$@% anything else?
#
#   Usage is simple. Either stdin to stdout or file.c.ppp to _file.c - it is
#   You can override output file with -o option.
#
#       ppp.pl [-D$perlvar=something] source.ext.ppp [source2.ext.ppp] [-pprefix (default="_")]
#                                                                      [-t (leave temp file)]
#                                                                      [-o (output file)]
#
#   We don't do includes or macro expansions - that's left to the real 
#   preprocessor/cpp.
#


#############################################################################
# Standard packages
#############################################################################
use Getopt::Long;
use File::Glob ':glob';


#############################################################################
# Constants
#############################################################################
$DEBUG        = 0;                  # DEBUG - save copy of _script.pl
$VERBOSE      = 0;                  # Require long demarkation
$time         = localtime(time);
$Revision     = '$Revision: 2 $';
$Revision     =~ s/.*: //;
$Revision     =~ s/ .*//;
$EXTENSION    = "ppp";              # default inbound extension


#############################################################################
# Set/Get options
#############################################################################
@cmd        = @ARGV;                # Save cmd-line for later
$prefix     = "_";
$output     = "";
$result = GetOptions("define=s"      => \@defines,       # string
                     "prefix=s"      => \$prefix,        # string
                     "temp"          => \$DEBUG,         # boolean
                     "output=s"      => \$output);       # boolean

# Process defines
foreach $define (@defines) {
    # Proceed each define with a $ so caller doesn't have to
    $define = "\$" . $define;
    eval $define;
}

# Get the filename(s)
# Convert filename globs to filenames
foreach $arg (@ARGV) {
    @files = (@files, bsd_glob($arg));
}

# For each file make sure exists and fix the extension if necessary.
# This is the incoming extention - not the same as -e option for output extension
foreach $file (@files) {
    if(-e $file) { next; }

    $file .= "." . "ppp";
    if(-e $file) { next; }

    die("$file not found.\n");
}

# If no files given look at STDIN
if(@files eq 0) {
    push @files, "STDIN";
}


#############################################################################
# Process Each File
#############################################################################
foreach $file_in (@files) {

    # Open if file else use STDIN
    if ($file_in eq "STDIN") {
        *FILE_IN    = *STDIN;
        *FILE_OUT   = *STDOUT;
    } else {
        if($output ne "") {
            $file_out = $output;
        } else {
            $file_out = $file_in;
            $file_out =~ s/^/$prefix/;        # Prepend prefix (if present)
            $file_out =~ s/\.$EXTENSION//;    # Remove default extension in (if present)
        }
        unless (open (FILE_IN,  "$file_in"))   { die  ("Cannot open \"$file_in\"\n"); }
        unless (open (FILE_OUT, ">$file_out")) { die  ("Cannot open \"$file_out\" for writing\n"); }
    }

    # Read entire input file
    @file_in = <FILE_IN>;
    close FILE_IN;

    # Try to suss out comment char
    $comment = "";
    foreach $line (@file_in) {
        if($comment eq "") {
            if($line =~ "^#") {
                $comment = "#";
                last;
            } elsif($line =~ "^/") {
                $comment = "//";
                last;
            } elsif($line =~ "^\s*--") {
                $comment = "--";
                last;
            } elsif($line =~ "^;") {
                $comment = ";";
                last;
            }
        }
    }
    # If not found assume ANSI style comments
    if($comment eq "") {
        $comment = "//";
    }

    # Initialize 'script' for this file
    $generated_by = "$comment Generated by $0 V$Revision from \"$file_in\" on $time\n";
    escape($generated_by);

    $script  = qq(print FILE_OUT "$generated_by";);
    $script .= qq(print FILE_OUT "$comment    Command line parameters: @cmd\n\n";);

    # Now process $file_in $line by $line
    while ($line = shift (@file_in)) {

        # If it is Perl use it directly (without the '!')
        # TODO: shouldn't escape be user-selectable?
        if ($line =~ /^!/) {
            $line =~ s/^!//; # rm key sequence
            $script .= $line;
            next;
        }


        # Otherwise, encapsulate with a print
        # Need to escape anything that Perl might process
        escape($line);
        $script .= qq(print FILE_OUT "$line";);
    }
    $script .= qq(print FILE_OUT "$generated_by";);

    # If debug save a copy of the script
    if($DEBUG) {
        $file_debug = $file_in;
        $file_debug =~ s/^/$prefix/;        # Prepend prefix (if present)
        $file_debug =~ s/\.$EXTENSION//;    # Remove default extension in (if present)
        $file_debug =~ s/$/.pl/;            # Append Perl fore debug
        unless (open (FILE_DEBUG, ">$file_debug")) { die  ("Cannot open \"$file_debug\" for writing\n"); }
        print FILE_DEBUG "\$file_out = \"$file_out\";\n";
        print FILE_DEBUG "unless (open (FILE_OUT, \">\$file_out\")) { die  (\"Cannot open \\\"$file_out\\\" for writing\\n\"); }\n";
        print FILE_DEBUG $script;
        print FILE_DEBUG "close FILE_OUT;\n";
        close FILE_DEBUG;
    }

    # Execute new script
    use warnings;
    eval $script;
    close FILE_OUT;
    if($@ ne "") { die("$@"); }
}

#############################################################################
# Subroutines
#############################################################################

# Escape special chars
sub escape {
    # Replace already escaped special chars with secret characters
    $_[0] =~ s/\\\[/©/g;
    $_[0] =~ s/\\\]/®/g;
    $_[0] =~ s/\\\{/«/g;
    $_[0] =~ s/\\\}/»/g;
    $_[0] =~ s/\\\@/ª/g;
    $_[0] =~ s/\\\$/¢/g;
    $_[0] =~ s/\\\%/±/g;

    # Need to escape anything that Perl might process
    $_[0] =~ s/\\/\\\\/g;
    $_[0] =~ s/\"/\\"/g;
    $_[0] =~ s/\[/\\[/g;
    $_[0] =~ s/\]/\\]/g;
    $_[0] =~ s/\%/\\%/g;
    $_[0] =~ s/\{/\\{/g;
    $_[0] =~ s/\}/\\}/g;
    $_[0] =~ s/@/\\@/g;
    $_[0] =~ s/\$/\\\$/g;

    # Put back Perl special characters - but unescaped so Perl can interpolate
    $_[0] =~ s/©/\[/g;
    $_[0] =~ s/®/\]/g;
    $_[0] =~ s/«/\{/g;
    $_[0] =~ s/»/\}/g;
    $_[0] =~ s/ª/\@/g;
    $_[0] =~ s/¢/\$/g;
    $_[0] =~ s/±/\%/g;
}
